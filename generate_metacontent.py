#!/usr/bin/python3.5

from os import listdir
from os.path import isfile, join

path = join("src", "Content")
contents = [f[:-4] for f in listdir(path) if isfile(join(path, f))]


def generate_part(template):
    return "\n".join([template.format(content) for content in contents])

def generate_part_union(template, indent):
    return "\n".join([indent + ("= " if i == 0 else "| ") + template.format(content) for i, content in enumerate(contents)])

parts = [
    generate_part("import Content.{0} as {0}"),
    generate_part_union("M{0} {0}.Model", "    "),
    generate_part_union("A{0} {0}.Action", "    "),
    generate_part("""\
        A{0} action ->
            case multiModel of
                M{0} model ->
                    let
                        (model', fx) = {0}.update action model
                    in
                        Just (M{0} model', Effects.map A{0} fx)
                _ ->
                    Debug.log mismatchError Nothing"""),
    generate_part("""\
        M{0} model ->
            {0}.view
                {{ context | actions = Signal.forwardTo context.actions A{0} }}
                model""")
]

base_code = """\
-- Autogenerated by generate_metacontent.py
-- If only Elm had type classes...

module MetaContent where

import ContentUtil
import Signal
import Html
import Effects exposing (Effects)

{}


-- MODEL

type MultiModel
{}


-- UPDATE

type MultiAction
{}

mismatchError: String
mismatchError = "MetaContent.update action model type mismatch"

update: MultiAction -> MultiModel -> Maybe (MultiModel, Effects MultiAction)
update multiAction multiModel =
    case multiAction of
{}


-- VIEW

view: ContentUtil.ViewContext MultiAction -> MultiModel -> Html.Html
view context multiModel =
    case multiModel of
{}"""

f = open(join("src", "MetaContent.elm"), "w")
f.write(base_code.format(*parts))
